#!/bin/bash
# * -- shell functions -- *
#
# Description	: run-level control functions
#
# Reference	: lfs-bootscripts
#
# Author	: yanyg	yygcode@gmail.com
# Version	: 1.0
# Copyright	: GLPv2
# Date		: Mon Mar 26 14:34:39 CST 2012
#

. /lib/services/getopt.sh

# NAME
#	start_daemon - start system daemon programs
#
# SYNOPSIS
#	start_daemon [OPTION]... [--] DAEMON [ARG]...
#
# DESCRIPTION
#	OPTIONs:
#		-f, --force		force running
#		-n, --nice		daemon nice
#		-p, --pidfile		daemon pid file pathname
#	If OPTIONs conflict with ARGs of DAEMON, then you should append
#	'--' just after all OPTIONs.
#
# RETURN VALUE
#	On success, zero is returned. Otherwise, non-zero is returned
#	0 - success
#	1 - daemon cannot execute
#	other - from pidofproc
start_daemon()
{
	local force nice=0 pidfile pidlist="" ret="" prog=""

	eval $(yc_getopt -ctrue -vyes -xprog \
		force,f nice,n,: pidfile,p,: -- "$@")

	[ -x "$prog" ] || return 1

	if [ -z "$force" ]; then
		pidlist=$(pidofproc ${pidfile:+-p $pidfile} "$1")
		ret=$?
		case "$ret" in
		0)
		# program is already running
		return 0
		;;
		1)
		# program dead but pidfile exists
		rm -f "$pidfile"
		;;
		2)
		# program is not running and pidfile doesn't exists
		:
		;;
		*)
		# some error take place
		return $ret
		;;
		esac
	fi

	# shift to prog
	while [ -n "$1" ] && [ "$1" != "$prog" ]; do shift; done

	# get pid
	pid=$(echo $BASHPID; exec nice -n "$nice" "$@")
	ret=$?
	[ -n "$pidfile" ] && echo $pid > $pidfile

	return $ret
}

# NAME
#	pidofproc - find the process ID of the program
#
# SYNOPSIS
#	pidofproc [OPTION]... [--] PROGRAM
#
# DESCRIPTION
#	OPTIONs:
#		-p, --pidfile		program pid file pathname
#
# RETURN VALUE
#	0 - program is running, print PIDs to stdout
#	1 - program is dead, pidfile exists
#	2 - program is not running
#	3 - arguments error
pidofproc()
{
	local pidfile="" prog="" lpids="" es=0

	eval $(yc_getopt pidfile,p,: "$@")

	if [ -z "$pidfile" ]; then
		local progbase=${prog##*/}
		[ -e "$progbase.pid" ] && pidfile=$progbase.pid
	fi

	if [ -n "$pidfile" ] && [ -e "$pidfile" ]; then
		pidlist=$(head -n1 "$pidfile")
	else
		pidlist=$(pidof "$prog")
	fi

	for pid in $pidlist; do
		kill -0 $pid 2>/dev/null
		if [ $? -eq 0 ]; then
			lpids="$lpids $pid"
		else
			es=1
		fi
	done

	if [ -z "$lpids" ] && [ ! -f "$pidfile" ]; then
		return 2
	fi

	echo $lpids
	return $es
}

# screen dimensions
stty_columns()
{
	local col=$(stty size 2>/dev/null)
	col=${col##* }
	if [ -z "$col" ] || [ "$col" = "0" ]; then
		col=80
	fi

	echo $col
}

[ -n "$COLUMNS" ] || COLUMNS=$(stty_columns)
COL=$((COLUMNS - 8))
WCOL=$((COL - 2))
# Set cursor position
SET_COL="\\033[${COL}G"
SET_WCOL="\\033[${WCOL}G"
CURS_UP="\\033[1A\\033[0G"

# color
NORMAL="\\033[0;39m"
SUCCESS="\\033[1;32m"
WARNING="\\033[1;33m"
FAILURE="\\033[1;31m"
INFO="\\033[1;36m"
BRACKET="\\033[1;34m"
BOOTLOG=/var/log/boot
KILLDELAY=2
