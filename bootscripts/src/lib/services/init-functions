#!/bin/bash
# * -- shell functions -- *
#
# Description	: run-level control functions
#
# Reference	: lfs-bootscripts
#
# Author	: yanyg	yygcode@gmail.com
# Version	: 1.0
# Copyright	: GLPv2
# Date		: Mon Mar 26 14:34:39 CST 2012
#

. /lib/services/getopt.sh

# NAME
#	start_daemon - start system daemon programs
#
# SYNOPSIS
#	start_daemon [OPTION]... [--] DAEMON [ARG]...
#
# DESCRIPTION
#	OPTIONs:
#		-f, --force		force running
#		-n, --nice		daemon nice
#		-p, --pidfile		daemon pid file pathname
#	If OPTIONs conflict with ARGs of DAEMON, then you should append
#	'--' just after all OPTIONs.
#
# RETURN VALUE
#	On success, zero is returned. Otherwise, non-zero is returned
#	0 - success
#	1 - daemon cannot execute
#	other - from pidofproc
start_daemon()
{
	local force nice=0 pidfile pidlist="" ret="" prog=""

	eval $(yc_getopt -o -ctrue -vyes -xprog \
		force,f nice,n,: pidfile,p,: -- "$@")

	if [ -z "$force" ]; then
		pidlist=$(pidofproc "$@")
		ret=$?
		case "$ret" in
		0)
		# program is already running
		return 0
		;;
		1)
		# program dead but pidfile exists
		rm -f "$pidfile"
		;;
		2)
		# program is not running and pidfile doesn't exists
		:
		;;
		*)
		# some error take place
		return $ret
		;;
		esac
	fi

	# shift to prog
	while [ -n "$1" ] && [ "$1" != "$prog" ]; do shift; done

	# get pid
	pid=$(echo $BASHPID; exec nice -n "$nice" "$@")
	ret=$?
	[ -n "$pidfile" ] && echo $pid > $pidfile

	return $ret
}

# NAME
#	stop_daemon - stop system daemon programs
#
# SYNOPSIS
#	stop_daemon [OPTION]... [--] DAEMON
#
# DESCRIPTION
#	OPTIONs:
#		-p, --pidfile		daemon pid file pathname
#		-t, --timeout		timeout
#
# RETURN VALUE
#	The same as killproc()
stop_daemon()
{
	killproc "$@" "-TERM" "-KILL"
}

# NAME
#	killproc - Send signal to running processes to stop it
#
# SYNOPSIS
#	killproc [OPTION]... [--] PROGRAM [SIGNAL]
#
# DESCRIPTION
#	OPTIONs:
#		-p, --pidfile		program pid file pathname
#		-t, --timeout		timeout
#
# RETURN VALUE
#	0 - program is running, print PIDs to stdout
#	1 - stop failed
#	2 - program is dead, pidfile exists, or program is not running
#	3 - arguments error
killproc()
{
	local pidfile pid pidlist ret timeout=3

	eval $(yc_getopt -ctrue -o -xprog pidfile,p,: timeout,t,: "$@")

	pidlist=$(pidofproc "$@")
	ret=$?

	# shift to prog
	while [ -n "$1" ] && [ "$1" != "$prog" ]; do shift; done

	case $ret in
	0)
	# program running, wait for send SIGNAL
	:
	;;
	1)
	# program is not running. pidfile exists.
	rm -f "$pidfile"
	return 2
	;;
	*)
	return $ret
	esac

	local signal="-TERM" fallback="-KILL"

	# signal set ?
	[ -n "${2#SIG}" ] && { signal=${2#SIG}; fallback=""; }
	[ -n "${3#SIG}" ] && fallback=${3#SIG}
	[ -n "${signal##-*}" ] && signal="-$signal"
	[ -n "${fallback##-*}" ] && fallback="-$fallback"

	for pid in $pidlist; do
		kill -0 $pid || continue
		kill "$signal" $pid 2>/dev/null

		local repeat=$((timeout * 10))
		while [ $repeat -ne 0 ]; do
			kill -0 $pid 2>/dev/null || break
			sleep 0.1
			: $((--repeat))
		done

		if [ $repeat -eq 0 ]; then
			[ -n "$fallback" ] && kill "$fallback" $pid 2>/dev/null
			sleep 1
			kill -0 $pid 2>/dev/null && return 1
		fi
	done

	[ -z "$pidfile" ] && pidfile=${prog##*/}.pid
	[ -e "$pidfile" ] && rm -f $pidfile
}

# NAME
#	pidofproc - find the process ID of the program
#
# SYNOPSIS
#	pidofproc [OPTION]... [--] PROGRAM
#
# DESCRIPTION
#	OPTIONs:
#		-p, --pidfile		program pid file pathname
#
# RETURN VALUE
#	0 - program is running, print PIDs to stdout
#	1 - program is dead, pidfile exists
#	2 - program is not running
#	3 - arguments error
pidofproc()
{
	local pidfile="" prog="" lpids="" es=0

	eval $(yc_getopt -o -ctrue -xprog pidfile,p,: "$@")

	if [ -z "$pidfile" ]; then
		local progbase=${prog##*/}
		[ -e "$progbase.pid" ] && pidfile=$progbase.pid
	fi

	if [ -n "$pidfile" ] && [ -e "$pidfile" ]; then
		pidlist=$(head -n1 "$pidfile")
	else
		pidlist=$(pidof "$prog")
	fi

	for pid in $pidlist; do
		kill -0 $pid 2>/dev/null
		if [ $? -eq 0 ]; then
			lpids="$lpids $pid"
		else
			es=1
		fi
	done

	if [ -z "$lpids" ] && [ ! -f "$pidfile" ]; then
		return 2
	fi

	echo $lpids
	return $es
}

# NAME
#	statusproc - status of program
#
# SYNOPSIS
#	statusproc [OPTION]... [--] PROGRAM
#
# DESCRIPTION
#	OPTIONs:
#		-p, --pidfile		program pid file pathname
#
# RETURN VALUE
#	0 - program is running
#	1 - program is dead, pidfile exists
#	2 - program is not running
#	3 - arguments error
statusproc()
{
	local pidfile pidlist pid prog

	eval $(yc_getopt -o -ctrue -xprog pidfile,p,: "$@")

	pidlist=$(pidofproc "$@")

	local progbase=${prog##*/}
	[ -z "$pidfile" ] && pidfile=$progbase.pid
	if [ -n "$pidlist" ]; then
		echo -e "${WARNING}$progbase is running with process" \
			"ID(s) $pidlist.${NORMAL}"
		return 0
	else
		if [ -n "$progbase" ] && [ -e "$pidfile" ]; then
			echo -e "${WARNING} $progbase is not running but " \
				"$pidfile exists.${NORMAL}"
		else
			echo -e "${INFO} $progbase is not running.${NORMAL}"
		fi
		return 1
	fi
}

# log
timespec()
{
	STAMP="$(echo `date +"%b %d %T"` `hostname`) "
}

log_success_msg()
{
	echo -n -e "$@"
	echo -e "${SET_COL}${BRACKET}[${SUCCESS}  OK  ${BRACKET}]${NORMAL}"

	timespec
	echo -e "${STAMP} ${@} OK" >> ${BOOTLOG}
	return 0
}

log_success_msg2()
{
	:
}

log_begin_msg()
{
	:
}

# screen dimensions
stty_columns()
{
	local col=$(stty size 2>/dev/null)
	col=${col##* }
	if [ -z "$col" ] || [ "$col" = "0" ]; then
		col=80
	fi

	echo $col
}

[ -n "$COLUMNS" ] || COLUMNS=$(stty_columns)
COL=$((COLUMNS - 8))
WCOL=$((COL - 2))
# Set cursor position
SET_COL="\\033[${COL}G"
SET_WCOL="\\033[${WCOL}G"
CURS_UP="\\033[1A\\033[0G"

# color
NORMAL="\\033[0;39m"
SUCCESS="\\033[1;32m"
WARNING="\\033[1;33m"
FAILURE="\\033[1;31m"
INFO="\\033[1;36m"
BRACKET="\\033[1;34m"
BOOTLOG=/var/log/boot
KILLDELAY=2
